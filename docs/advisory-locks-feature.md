# Advisory Locks Feature

## Overview

The advisory locks feature extends the DCB event store with the ability to acquire PostgreSQL advisory locks based on event tags. This provides a way to serialize access to specific aggregates or resources without blocking unrelated operations.

## How It Works

### Function: `append_events_with_advisory_locks`

This function has the same contract as `append_events_with_condition` but adds advisory locking functionality:

```sql
CREATE OR REPLACE FUNCTION append_events_with_advisory_locks(
    p_types TEXT[],
    p_tags TEXT[],
    p_data JSONB[],
    p_condition JSONB DEFAULT NULL
) RETURNS VOID
```

### Lock Tag Convention

Tags with the prefix `lock:` are used for advisory locks:

- **Input**: `["user:123", "lock:user:123", "tenant:acme"]`
- **Lock Key**: `"user:123"` (removes `lock:` prefix)
- **Stored Tags**: `["user:123", "tenant:acme"]` (removes `lock:` tags entirely)

### Lock Acquisition Process

1. **Parse Tags**: Extract lock keys from tags starting with `lock:`
2. **Sort Keys**: Sort lock keys alphabetically to prevent deadlocks
3. **Acquire Locks**: Use `pg_advisory_xact_lock()` for each lock key
4. **Clean Tags**: Remove `lock:` prefix from all tags before storage
5. **Append Events**: Proceed with normal append logic

## Usage Examples

### Basic Usage

```sql
-- Single event with lock
SELECT append_events_with_advisory_locks(
    ARRAY['UserCreated'],
    ARRAY['{"user:123", "lock:user:123", "tenant:acme"}'],
    ARRAY['{"name": "John Doe"}'::jsonb]
);
```

### Multiple Events with Same Lock

```sql
-- Both events will serialize access to order:456
SELECT append_events_with_advisory_locks(
    ARRAY['OrderCreated', 'ItemAdded'],
    ARRAY['{"order:456", "lock:order:456", "customer:789"}', '{"order:456", "lock:order:456", "item:123"}'],
    ARRAY['{"total": 100}'::jsonb, '{"item_id": "123", "quantity": 2}'::jsonb]
);
```

### Multiple Lock Keys

```sql
-- Acquires locks for both accounts (sorted to prevent deadlocks)
SELECT append_events_with_advisory_locks(
    ARRAY['TransactionProcessed'],
    ARRAY['{"transaction:999", "lock:account:111", "lock:account:222", "amount:500"}'],
    ARRAY['{"from_account": "111", "to_account": "222", "amount": 500}'::jsonb]
);
```

### With Append Conditions

```sql
-- Combines advisory locks with DCB append conditions
SELECT append_events_with_advisory_locks(
    ARRAY['UserUpdated'],
    ARRAY['{"user:123", "lock:user:123", "tenant:acme"}'],
    ARRAY['{"name": "Jane Doe"}'::jsonb],
    '{"fail_if_events_match": {"items": [{"event_types": ["UserCreated"], "tags": ["user:123"]}]}}'::jsonb
);
```

## Benefits

### 1. **Concurrency Control**
- Prevents race conditions on the same aggregate
- Serializes modifications to specific resources
- Maintains consistency without global locks

### 2. **Performance**
- Only blocks operations on the same lock keys
- Unrelated operations proceed normally
- No impact on read operations

### 3. **DCB Compatibility**
- Same interface as existing append functions
- Works with all existing append conditions
- Backward compatible (events without lock tags work normally)

### 4. **Deadlock Prevention**
- Lock keys are sorted before acquisition
- Consistent ordering prevents deadlocks
- Transaction-scoped locks auto-release on commit/rollback

## Implementation Details

### Lock Key Generation

Lock keys are generated by:
1. Finding tags starting with `lock:`
2. Removing the `lock:` prefix
3. Using the remaining string as the lock key

### Advisory Lock Usage

Uses PostgreSQL's `pg_advisory_xact_lock()` function:
- **Transaction-scoped**: Automatically released on commit/rollback
- **Hash-based**: Converts string keys to hash values
- **Non-blocking reads**: Read operations are not affected

### Tag Processing

The function processes tags in two phases:
1. **Lock Phase**: Extract and acquire locks for `lock:` prefixed tags
2. **Storage Phase**: Store events with cleaned tags (no `lock:` prefix)

## Integration with Go Code

### Direct Function Call

```go
// Call the advisory lock function directly
_, err := db.ExecContext(ctx, `
    SELECT append_events_with_advisory_locks($1, $2, $3, $4)
`, types, tags, data, conditionJSON)
```

### Event Preparation

```go
// Prepare events with lock tags
events := []Event{
    {
        Type: "UserCreated",
        Tags: []string{"user:123", "lock:user:123", "tenant:acme"},
        Data: map[string]interface{}{"name": "John Doe"},
    },
}
```

## Testing

### Unit Tests

Run the advisory lock tests:

```bash
go test ./pkg/dcb -v -run TestAdvisoryLocks
```

### Integration Tests

Test with actual database:

```bash
# Start database
docker-compose up -d

# Run SQL tests
psql -h localhost -U postgres -d dcb_app -f test_advisory_locks.sql
```

## Limitations

### 1. **Lock Key Length**
- PostgreSQL advisory locks use hash values
- Very long lock keys may have hash collisions
- Recommended: Keep lock keys under 100 characters

### 2. **Transaction Scope**
- Locks are transaction-scoped
- Long-running transactions hold locks longer
- Consider breaking large operations into smaller transactions

### 3. **Lock Key Design**
- Choose lock keys that represent the actual resource being protected
- Use consistent naming conventions
- Avoid too many different lock keys (can impact performance)

## Best Practices

### 1. **Lock Key Naming**
```sql
-- Good: Specific and consistent
"lock:user:123"
"lock:order:456"
"lock:account:789"

-- Avoid: Too generic or inconsistent
"lock:resource"
"lock:User:123"  -- Inconsistent casing
```

### 2. **Minimal Lock Scope**
```sql
-- Good: Lock only the specific aggregate
"lock:user:123"

-- Avoid: Locking too broadly
"lock:user"  -- Would block all user operations
```

### 3. **Combining with Conditions**
```sql
-- Use both locks and conditions for maximum consistency
SELECT append_events_with_advisory_locks(
    ARRAY['UserUpdated'],
    ARRAY['{"user:123", "lock:user:123"}'],
    ARRAY['{"name": "Jane"}'::jsonb],
    '{"fail_if_events_match": {"items": [{"event_types": ["UserCreated"], "tags": ["user:123"]}]}}'::jsonb
);
```

## Migration Guide

### From `append_events_with_condition`

1. **Identify Critical Sections**: Find operations that need serialization
2. **Add Lock Tags**: Add `lock:` prefixed tags to those events
3. **Switch Function**: Change from `append_events_with_condition` to `append_events_with_advisory_locks`
4. **Test Thoroughly**: Verify lock behavior and performance

### Example Migration

```sql
-- Before
SELECT append_events_with_condition(
    ARRAY['UserUpdated'],
    ARRAY['{"user:123", "tenant:acme"}'],
    ARRAY['{"name": "Jane"}'::jsonb]
);

-- After
SELECT append_events_with_advisory_locks(
    ARRAY['UserUpdated'],
    ARRAY['{"user:123", "lock:user:123", "tenant:acme"}'],
    ARRAY['{"name": "Jane"}'::jsonb]
);
```

## Troubleshooting

### Common Issues

1. **Lock Timeouts**: Increase `lock_timeout` if needed
2. **Deadlocks**: Ensure lock keys are sorted (handled automatically)
3. **Performance**: Monitor lock contention and adjust lock key granularity

### Monitoring

```sql
-- Check for active advisory locks
SELECT * FROM pg_locks WHERE locktype = 'advisory';

-- Check for lock waiters
SELECT * FROM pg_stat_activity WHERE wait_event_type = 'Lock';
``` 